#!/bin/sh

###############################################################################
export SYSTEM_TYPE=`python -u -c 'import platform;print(platform.system())'`

export PATH=$PATH:$DIFOSS_ENV_BASE/my_cmd


if [ -z `command -v realpath` ]; then
    realpath () {
        f=$@;
        if [ -d "$f" ] ; then
            base="";
            dir="$f";
        else
            base="/$(basename "$f")";
            dir=$(dirname "$f");
        fi
        dir=$(cd "$dir" && /bin/pwd);
        echo "$dir$base"
    }
fi

if [ "$SYSTEM_TYPE" == "Windows" ] ; then

    # Config Cygwin Here ------------------------------------
    export CYGPATH=cygpath.exe

    alias p='powershell -command "ps | head -3 >&2; ps |grep $*" ' # $* $@

    # Set alias for *.bat of `Git/cmd` diretory
    function e() {
        if [ -z $1 ]; then
            explorer `cygpath -w $PWD`
        else
            cygpath -w "`realpath $1`" | awk '{printf "explorer \"%s\"", $0}' | sh
        fi
    }

elif [ "$SYSTEM_TYPE" == "Linux" ] ; then
    export CYGPATH=echo
    export IP_ETH0=`ip -f inet address show  | grep -A 1 -E "[[:digit:]]+\: eth0:" | tail -1 | awk -F"[ //]+" '{print $3}'`
    export ADDR_1st=`cat /proc/net/dev | awk '{i++; if(i>2){print $1}}'|grep -v lo| awk -F ':' '{print $1}'| head -1`
    export IP_1st=`ip -f inet address show | grep -A 1 -E "[[:digit:]]+\: $ADDR_1st:" | tail -1 | awk -F"[ //]+" '{print $3}'`

    if [ -z `command -v __git_ps1` ]; then

function  __git_eread ()
{
    test -r "$1" && IFS='
' read "$2" < "$1"
}

function  __git_ps1 ()
{
    local exit=$?;
    local pcmode=no;
    local detached=no;
    local ps1pc_start='\u@\h:\w ';
    local ps1pc_end='\$ ';
    local printf_format=' (%s)';
    case "$#" in
        2 | 3)
            pcmode=yes;
            ps1pc_start="$1";
            ps1pc_end="$2";
            printf_format="${3:-$printf_format}";
            PS1="$ps1pc_start$ps1pc_end"
        ;;
        0 | 1)
            printf_format="${1:-$printf_format}"
        ;;
        *)
            return $exit
        ;;
    esac;
    local ps1_expanded=yes;
    [ -z "${ZSH_VERSION-}" ] || [[ -o PROMPT_SUBST ]] || ps1_expanded=no;
    [ -z "${BASH_VERSION-}" ] || shopt -q promptvars || ps1_expanded=no;
    local repo_info rev_parse_exit_code;
    repo_info="$(git rev-parse --git-dir --is-inside-git-dir 		--is-bare-repository --is-inside-work-tree 	 --short HEAD 2>/dev/null)";
    rev_parse_exit_code="$?";
    if [ -z "$repo_info" ]; then
        return $exit;
    fi;
    local short_sha="";
    if [ "$rev_parse_exit_code" = "0" ]; then
        short_sha="${repo_info##*
}";
        repo_info="${repo_info%
*}";
    fi;
    local inside_worktree="${repo_info##*
}";
    repo_info="${repo_info%
*}";
    local bare_repo="${repo_info##*
}";
    repo_info="${repo_info%
*}";
    local inside_gitdir="${repo_info##*
}";
    local g="${repo_info%
*}";
    if [ "true" = "$inside_worktree" ] && [ -n "${GIT_PS1_HIDE_IF_PWD_IGNORED-}" ] && [ "$(git config --bool bash.hideIfPwdIgnored)" != "false" ] && git check-ignore -q .; then
        return $exit;
    fi;
    local r="";
    local b="";
    local step="";
    local total="";
    if [ -d "$g/rebase-merge" ]; then
        __git_eread "$g/rebase-merge/head-name" b;
        __git_eread "$g/rebase-merge/msgnum" step;
        __git_eread "$g/rebase-merge/end" total;
        if [ -f "$g/rebase-merge/interactive" ]; then
            r="|REBASE-i";
        else
            r="|REBASE-m";
        fi;
    else
        if [ -d "$g/rebase-apply" ]; then
            __git_eread "$g/rebase-apply/next" step;
            __git_eread "$g/rebase-apply/last" total;
            if [ -f "$g/rebase-apply/rebasing" ]; then
                __git_eread "$g/rebase-apply/head-name" b;
                r="|REBASE";
            else
                if [ -f "$g/rebase-apply/applying" ]; then
                    r="|AM";
                else
                    r="|AM/REBASE";
                fi;
            fi;
        else
            if [ -f "$g/MERGE_HEAD" ]; then
                r="|MERGING";
            else
                if [ -f "$g/CHERRY_PICK_HEAD" ]; then
                    r="|CHERRY-PICKING";
                else
                    if [ -f "$g/REVERT_HEAD" ]; then
                        r="|REVERTING";
                    else
                        if [ -f "$g/BISECT_LOG" ]; then
                            r="|BISECTING";
                        fi;
                    fi;
                fi;
            fi;
        fi;
        if [ -n "$b" ]; then
            :;
        else
            if [ -h "$g/HEAD" ]; then
                b="$(git symbolic-ref HEAD 2>/dev/null)";
            else
                local head="";
                if ! __git_eread "$g/HEAD" head; then
                    return $exit;
                fi;
                b="${head#ref: }";
                if [ "$head" = "$b" ]; then
                    detached=yes;
                    b="$(
				case "${GIT_PS1_DESCRIBE_STYLE-}" in
				(contains)
					git describe --contains HEAD ;;
				(branch)
					git describe --contains --all HEAD ;;
				(tag)
					git describe --tags HEAD ;;
				(describe)
					git describe HEAD ;;
				(* | default)
					git describe --tags --exact-match HEAD ;;
				esac 2>/dev/null)" || b="$short_sha...";
                    b="($b)";
                fi;
            fi;
        fi;
    fi;
    if [ -n "$step" ] && [ -n "$total" ]; then
        r="$r $step/$total";
    fi;
    local w="";
    local i="";
    local s="";
    local u="";
    local c="";
    local p="";
    if [ "true" = "$inside_gitdir" ]; then
        if [ "true" = "$bare_repo" ]; then
            c="BARE:";
        else
            b="GIT_DIR!";
        fi;
    else
        if [ "true" = "$inside_worktree" ]; then
            if [ -n "${GIT_PS1_SHOWDIRTYSTATE-}" ] && [ "$(git config --bool bash.showDirtyState)" != "false" ]; then
                git diff --no-ext-diff --quiet || w="*";
                git diff --no-ext-diff --cached --quiet || i="+";
                if [ -z "$short_sha" ] && [ -z "$i" ]; then
                    i="#";
                fi;
            fi;
            if [ -n "${GIT_PS1_SHOWSTASHSTATE-}" ] && git rev-parse --verify --quiet refs/stash > /dev/null; then
                s="$";
            fi;
            if [ -n "${GIT_PS1_SHOWUNTRACKEDFILES-}" ] && [ "$(git config --bool bash.showUntrackedFiles)" != "false" ] && git ls-files --others --exclude-standard --directory --no-empty-directory --error-unmatch -- ':/*' > /dev/null 2> /dev/null; then
                u="%${ZSH_VERSION+%}";
            fi;
            if [ -n "${GIT_PS1_SHOWUPSTREAM-}" ]; then
                __git_ps1_show_upstream;
            fi;
        fi;
    fi;
    local z="${GIT_PS1_STATESEPARATOR-" "}";
    if [ $pcmode = yes ] && [ -n "${GIT_PS1_SHOWCOLORHINTS-}" ]; then
        __git_ps1_colorize_gitstring;
    fi;
    b=${b##refs/heads/};
    if [ $pcmode = yes ] && [ $ps1_expanded = yes ]; then
        __git_ps1_branch_name=$b;
        b="\${__git_ps1_branch_name}";
    fi;
    local f="$w$i$s$u";
    local gitstring="$c$b${f:+$z$f}$r$p";
    if [ $pcmode = yes ]; then
        if [ "${__git_printf_supports_v-}" != yes ]; then
            gitstring=$(printf -- "$printf_format" "$gitstring");
        else
            printf -v gitstring -- "$printf_format" "$gitstring";
        fi;
        PS1="$ps1pc_start$gitstring$ps1pc_end";
    else
        printf -- "$printf_format" "$gitstring";
    fi;
    return $exit
}
    fi
    export PS1='\e[36;2m<\t>\e[0m[\e[33;2m\u@\e[32;2m$IP_1st\e[0m] \e[35;2m\w\e[0m\e[36m$(__git_ps1 " (%s)")\e[0m\n$ '
    PROMPT_COMMAND='export PS1="`echo $PS1` "'

    ## old version of 'p'
    #alias p='echo -e "PID\tPPID\tCMD"; ps -eo "%P %p %c %a" -u $LOGNAME|egrep -vE "[[:space:]]*[[:digit:]]+[[:space:]]+[[:digit:]]+[[:space:]]+grep"|grep'

    alias p='ps -eo "%U %p %P %x %c %a"|head -1 >&2; ps -eo "%U %p %P %x %c %a"|egrep -vE "[[:space:]]*[[:digit:]]+[[:space:]]+[[:digit:]]+[[:space:]]+grep"|grep'
else
    echo Unknown System Type !
fi

# if [ "$OSTYPE" == $"linux-gnu" ]; then          ######### linux-gnu system
#    alias shutdown='echo'  # 防止错误关机
# fi

if [ "$TERM" == $"cygwin" ] && [ "$OSTYPE" == $"cygwin" ]; then  ##### cygwin, but not the original terminal
    export PS1="\e[36;2m<\t> \e[32;2m[\u@\h] \e[35;2m\w\e[0m\n$ "
fi

if [ "$OSTYPE" == $"cygwin" ]; then              ##### cygwin, no matter it is the original terminal
    # quik open explorer in $1 directory
    alias e='_e() { if [ $# -ne 1 ]; then explorer .; else explorer `cygpath -d "$*"`; fi }; _e'
fi
###############################################################################

# User specific aliases and functions

# color flag effect `grep`, `ls` and so on...
export COLOR_FLAG="auto"
function set_grep_color() {
    case "$#" in
      1)
        export COLOR_FLAG="$1"
      ;;
    esac
}

alias grep.color.auto='set_grep_color auto'
alias grep.color.yes='set_grep_color yes'
alias grep.color.no='set_grep_color no'

#### add default parameters to some command
alias rm='rm -i'
alias cp='cp -i'
alias mv='mv -i'
alias vi='vim'
alias ls="ls --show-control-chars --color=auto -A"
alias l='ls --show-control-chars --color=auto -Ah'
alias ll='ls --show-control-chars --color=auto -lAh'
alias lll='ls --show-control-chars --color=auto -lA'
alias grep='grep --color=$COLOR_FLAG'

# Let `grep` highlight
export GREP_COLOR="10;33"

#### short command
#alias r='perl $DIFOSS_ENV_BASE/run.pl'

# short for 'Grep Include'
alias check='valgrind --tool=memcheck --track-fds=yes --leak-check=full --show-leak-kinds=definite'
ulimit -c unlimited

###############################################################################
# 查找相关
# see config file
alias seecfg='grep -P "^\s*[^#]+"'
alias seecfgn='grep -nP "^\s*[^#]+"'
alias seeenv='python $DIFOSS_ENV_BASE/see_env.py'

alias g='grep -nrI --color=$COLOR_FLAG'
alias gi="grep -naE '#\s*include'"

alias f.c++='find . -type f -print0 | grep --color=no -zaiE ".*\.(cpp|hpp|c|h|hh|cxx|cc)$"|xargs -0 grep -aHn --color=$COLOR_FLAG'

alias f.java='grep -rIaHn --include="*.java" --color=$COLOR_FLAG'

# find callback
alias f.cb='find_callback(){ str="[>\.]+\s*"$@"\s*\("; find . -type f -print0 | grep --color=no -zaiE ".*\.(cpp|hpp|c|h|hh|cxx|cc)$"|xargs -0 grep -aHnP --color=$COLOR_FLAG $str; }; find_callback'
# find call
alias f.call='find_call(){ str="[^a-zA-Z_]+"$@"\s*\("; find . -type f -print0 | grep --color=no -zaE ".*\.(cpp|hpp|c|h|hh|cxx|cc)$"|xargs -0 grep -aHnp --color=$COLOR_FLAG $str; }; find_call'

# find in implementation files of C/C++ ( file suffix: cpp,c,cxx,cc,C )
alias f.cpp='find . -type f -print0 | grep --color=no -zaiE ".*\.(cpp|c|cxx|cc)$" | xargs -0 grep -aHn --color=$COLOR_FLAG'
# find in header of header files of C/C++ ( file suffix: h,hpp,hxx )
alias f.h='find . -type f -print0 | grep --color=no -zaiE ".*\.(hpp|h|hh|hxx)$" | xargs -0 grep -aHn --color=$COLOR_FLAG'
# find in makefiles ( file name: M/makefile, *.mk, *.mak )
alias f.mk="find . -type f -print0 | grep --color=no -zaiE '(\.mak$)|(\.c?make$)|(\.mk$)|(/.*makefile[^//]*$)|(/cmakelists.txt$)|(BUILD$)|(WORKSPACE$)|(\.bzl$)|(\.gradle$)' | xargs -0 grep -aHn --color=\$COLOR_FLAG"

#---------------------------
alias f.syslog="find /var/log -type f -name 'syslog' | xargs grep -aH --color=\$COLOR_FLAG"
#alias cl.syslog="cp /var/log/syslog /var/log/syslog-`date +%Y-%m-%d`.bak; cat /dev/null > /var/log/syslog"
alias f.log='find . -type f -name "*.log" -print0 | xargs -0 grep -aHn --color=$COLOR_FLAG'
alias f.ini='find . -type f -print0 | grep --color=no -zaiE ".*\.(ini|cfg|conf|xml|json)$" | xargs -0 grep -aHn --color=$COLOR_FLAG'

alias f.php='find . -type f -name "*.php" -print0 | xargs -0 grep -aHn --color=$COLOR_FLAG'
alias f.sql='find . -type f -name "*.sql" -print0 | xargs -0 grep -aHn --color=$COLOR_FLAG'
alias f.md='find . -type f -name "*.md" -print0 | xargs -0 grep -aHn --color=$COLOR_FLAG'
alias f.pb='find . -type f -print0 | grep --color=no -zaiE "(\.proto$)" | xargs -0 grep -aHn --color=$COLOR_FLAG'

alias f.js='find . -type f -print0 | grep --color=no -zaiE ".*\.(js|ts)$" | xargs -0 grep -aHn --color=$COLOR_FLAG'

alias f.go='find . -type f -print0 | grep --color=no -zaiE ".*\.(go)$" | xargs -0 grep -aHn --color=$COLOR_FLAG'
alias f.gosrc='find . -path "./vendor/*" -prune -o -name "*.go" -type f -print0 | xargs -0 grep -aHn --color=$COLOR_FLAG'
alias f.lua='find . -type f -print0 | grep --color=no -zaiE ".*\.(lua)$" | xargs -0 grep -aHn --color=$COLOR_FLAG'
alias f.thrift='find . -type f -name "*.thrift" -print0 | xargs -0 grep -aHn --color=$COLOR_FLAG'

alias f.bazel='find -type f -name "BUILD*" -print0 | xargs -0 grep -aHn --color=$COLOR_FLAG'
alias bn='find -type f -name BUILD -print0 | xargs -0 grep -aHn --color=$COLOR_FLAG name| grep'

# Set default `f` for MOST quickly find
alias f 2<&- 1<&-
if [ $? -eq 1 ]; then
    alias f=f.c++
fi

#---------------------------
## <need other files>
# read symbol in *.*o, but just 1 depth. (transfer 'low-level name' into 'C++ readable name' by <find_symbol_in_so.pl>)
alias f.symbol='perl $DIFOSS_ENV_BASE/find_symbol_in_so.pl'
alias f.so='find . -type f -print0 | grep --color=no -zaiE ".*\.(so|o|lo|a|ar)$" |xargs -0 nm -CA 2>/dev/null | grep -a --color=$COLOR_FLAG'
# Provider: https://github.com/zeroleo12345
alias ff='python $DIFOSS_ENV_BASE/ff.py'

#---------------------------
# find py
alias pyf='find -type f -name "*.py" -print0 |xargs -0 grep -aHn --color=$COLOR_FLAG'
alias f.py='pyf'
# find function defination in py
alias pyfn='find -type f -name "*.py" -print0 |xargs -0 grep -anE "^\s*def\s+" |grep -0 --color=$COLOR_FLAG'
# find function calling in py
alias pyfc='find -type f -name "*.py" -print0 |xargs -0 grep -anvE "^\s*def\s+" |grep -0 --color=$COLOR_FLAG'
alias pyc='find -type f -name "*.py" -print0 |xargs -0 grep -anE "^\s*class\s+" |grep -0 --color=$COLOR_FLAG'

alias pyhelp='python $DIFOSS_ENV_BASE/py.help.py'
alias pydir='python $DIFOSS_ENV_BASE/py.dir.py'
alias pyv='python -c "import sys; print sys.version"'
alias cd.py='cd /media/sf_software_develop_/python; alias f=f.py'

alias pd=pydir
alias ph=pyhelp

###############################################################################
# 编译相关
alias m="find -maxdepth 1 -type f | grep --color=no -iE '(.*\.mak$)|(.*\.mk$)|(makefile)$' |awk -F / '{print $2}'| xargs -I {} make -f $1 {}"
alias mc='m clean'
alias mi='m install'
alias c='cmake .'

# find rfc*.txt
alias f.rfc='find -type f -name "rfc*.txt" -print0 |xargs -0 grep -an --color=$COLOR_FLAG'

###############################################################################
# 爬虫相关
## pwebs: Pick WEB, grep by Single quotes
alias pwebs="awk -F \"[']\" '{i=1;while(i<NF) {printf(\"%s\n\", \$i);i++}}'"
## pwebd: Pick WEB, grep by Double quotes
alias pwebd="awk -F'\"' '{i=1;while(i<NF) {printf(\"%s\n\", \$i);i++}}'"
## geturl是pwebs、pwebd的混合版，使用 \047 代替单引号。后面可以再跟过滤用关键字（todo: 或者干脆紧跟URL规则的grep）
alias geturl="awk -F'[\"\047]' '{i=1;while(i<NF) {printf(\"%s\n\", \$i);i++}}'"
# 下载全站网页
alias getweb='wget -c -t 3 -r -p -k -E -A=zip,jpg,jpeg,png,gif,html,css'
# 文件的减法
alias filesub='python $DIFOSS_ENV_BASE/sub_file.py'


###############################################################################
# Git
alias gl="git log --graph --pretty=format:'%Cred%h%Creset - %Cgreen(%cd)%Creset %C(yellow)%d%Creset %C(yellow reverse)%cn%Creset %s' --abbrev-commit --date=format:%c"
alias gs="git status"
alias gb='git branch -vva'
alias gc='git checkout'
alias gitlog=gl
alias git.unset-credential='git config --system --unset credential.help'
###############################################################################
# bash 相关
alias b.reload='source $HOME/.bashrc'
alias b.rc='vim $HOME/.bashrc && source $HOME/.bashrc'
alias b.alias='vim $DIFOSS_ENV_BASE/my_alias && source $DIFOSS_ENV_BASE/my_alias'

###############################################################################
# 目录相关
alias ..="cd .."
alias cd..="cd .."
alias ...="cd ../.."
alias ....="cd ../../.."
alias .....="cd ../../../.."
alias -- -='cd -'
# cd save : save where i am
alias cds='echo "`pwd`" > ~/.cdsave'
# cd back
alias cdb='cd "`cat ~/.cdsave`"'


# entry last logout directory when login
#if [ -f ~/.cd-last-logout ];then
#    cd "`cat ~/.cd-last-logout`"
#fi

# exit and save lastest directory when logout
alias exit='echo $PWD > ~/.cd-last-logout; exit'

###############################################################################
## 函数类

# 创建一个目录并跳转到
# make a dir and cd into it
mkcd(){
    mkdir -pv "$@" && cd "$@"
}


# quick to send file ( use scp inner )
function sendto() {

    case "$#" in
        2)  # 带 2 个参数的话，
            local machine_name=$1;
            local file=$2;
            local rpath="`realpath $file`"

            local user=`whoami`
            local cmd

            if [ -d $rpath ]; then
               cmd="scp -r \"$file\" $user@$machine_name:$rpath"
            else
               cmd="scp \"$file\" $user@$machine_name:$rpath"
            fi

            echo $cmd
            echo $cmd | sh
            return 1
        ;;
        *)
            echo "Usage: sendto <ip/host> <file>" >&2
        ;;
    esac

    return 0
}

